---
title: 从模糊的一个点说起：深度解析 MTF 的计算原理与 PSF/ESF 转换
date: 2026-01-13 18:00:00
tags: [光学设计, MTF, 图像处理, 信号处理, PSF, 斜边法]
categories: 光学工程
mathjax: true
excerpt: 我们都知道 MTF 是评价镜头清晰度的金标准，但你是否好奇它是怎么算出来的？为什么说 MTF 是 PSF 的傅里叶变换？工业界为何不直接测点，而是测“斜边”？本文带你推导 ESF -> LSF -> MTF 的完整数学链路。
---

在光学设计和镜头测评中，MTF (Modulation Transfer Function) 曲线是绝对的权威。
但对于很多工程师来说，MTF 的计算过程像是一个黑盒：输入一张图，输出一条曲线。

这个黑盒里到底发生了什么？其实，一切都要从一个“点”说起。

---

## 01. 一切的源头：点扩散函数 (PSF)

想象在一个漆黑的宇宙中，有一颗无限远、无限小的恒星（理想的点光源）。
当这颗恒星的光经过你的镜头，打在传感器上时，它还会是一个完美的几何点吗？

绝不可能。
由于衍射极限（物理规律）和像差（镜头缺陷），这个点会散开，变成一个模糊的光斑。
这个光斑在空间上的亮度分布，就叫 **点扩散函数 (Point Spread Function, PSF)**。

* **理想镜头**：PSF 是一个完美的艾里斑 (Airy Disk)。
* **真实镜头**：PSF 是一个不规则的、弥散的能量团。

**核心物理意义**：
成像系统对图像的处理，本质上就是物体与系统 PSF 的**卷积 (Convolution)**。
$$Image(x, y) = Object(x, y) * PSF(x, y)$$



---

## 02. 从空间到频率：MTF 与傅里叶变换

PSF 是在**空间域 (Spatial Domain)** 描述模糊程度的（光斑直径多少微米）。
MTF 是在**频率域 (Frequency Domain)** 描述对比度衰减的（每毫米多少线对时对比度剩多少）。

连接这两个世界的桥梁，就是**傅里叶变换**。

**光学传递函数 (OTF)** 被定义为 PSF 的傅里叶变换：
$$OTF(u, v) = \mathcal{F}\{PSF(x, y)\}$$

而我们常说的 **MTF**，其实就是 OTF 的模（取绝对值）：
$$MTF(u, v) = |OTF(u, v)|$$

**通俗理解**：
* PSF 越尖锐（光斑越小） $\rightarrow$ 傅里叶变换后的频谱越宽 $\rightarrow$ MTF 曲线下降得越慢（高频高）。
* PSF 越弥散（光斑越大） $\rightarrow$ 傅里叶变换后的频谱越窄 $\rightarrow$ MTF 曲线掉得越快（高频糊）。

---

## 03. 工业界实战：为什么要用“斜边法”？

虽然理论上 $MTF = |\mathcal{F}(PSF)|$，但在实际测量中，直接拍摄一个微小的“点”来计算 PSF 是非常困难的：
1.  **能量太弱**：一个微米级的针孔过光量太少，信噪比 (SNR) 极差，会被噪声淹没。
2.  **对齐困难**：很难保证这个点正好落在像素中心。

所以，工业界（包括 ISO 12233 标准）几乎都使用 **“斜边法” (Slanted Edge Method)**。

我们不测点，我们测一条**刀锋边缘 (Edge)**。

### 计算链路推导：ESF $\to$ LSF $\to$ MTF

这是一个经典的三步走过程：

#### 第一步：获取边缘扩散函数 (ESF)
拍摄一张黑白分明的斜边图像。
理想情况下，边缘应该是 0 到 1 的阶跃跳变。但经过模糊的镜头后，边缘会有一个渐变的过渡区。
如果在垂直于边缘的方向上截取亮度数据，我们得到的一条 S 型曲线，这就是 **边缘扩散函数 (Edge Spread Function, ESF)**。
*注：ESF 本质上是 PSF 的二维积分。*



#### 第二步：获取线扩散函数 (LSF)
数学告诉我们，对阶跃响应求导，就是脉冲响应。
同理，对 **ESF 求导（微分）**，就得到了 **线扩散函数 (Line Spread Function, LSF)**。
$$LSF(x) = \frac{d}{dx} ESF(x)$$

LSF 代表的是一条无限细的亮线经过镜头后变宽的亮度分布。
*注：LSF 本质上是 PSF 在某个方向上的一维积分（投影）。*

#### 第三步：LSF 变 MTF
最后，对一维的 LSF 进行**一维傅里叶变换 (FFT)**，并进行归一化，就得到了 MTF。

$$MTF(\nu) = \left| \int_{-\infty}^{\infty} LSF(x) e^{-i 2\pi \nu x} dx \right|$$

通常我们会把零频率 ($MTF(0)$) 归一化为 1。

---

## 04. 仿真软件（Zemax）是怎么算的？

如果你不是在测实物，而是在 Zemax/CodeV 里做设计，软件并没有去“拍摄”边缘，它是怎么算出 MTF 的？

它有两种核心算法：

### 1. 基于 FFT (快速傅里叶变换)
这是最常用的方法。
1.  软件计算出光瞳面上的**波前像差 (Wavefront Error)**。
2.  计算**光瞳函数 (Pupil Function)**（包含振幅和相位）。
3.  对光瞳函数做**自相关 (Autocorrelation)**，直接得到 OTF。
    $$OTF = P(x, y) \star P(x, y)$$
    *或者先对光瞳函数做 FFT 得到 PSF，再对 PSF 做 FFT 得到 OTF。*

### 2. 基于 Huygens (惠更斯积分)
当像差很大或者不连续时使用。
它直接模拟无数个子波源在像面上的相干叠加，硬算出 PSF，然后再 FFT 得到 MTF。这种方法更准但更慢。

---

## 05. 总结

MTF 的计算并不是玄学，它是一条严密的数学链条：

| 物理对象 | 数学函数 | 关系 |
| :--- | :--- | :--- |
| **点 (Point)** | **PSF** | 系统的基本响应单元 |
| **线 (Line)** | **LSF** | PSF 的一维投影 |
| **边 (Edge)** | **ESF** | LSF 的积分 (实际最好测) |
| **清晰度** | **MTF** | LSF 的傅里叶变换 |

**实际操作口诀**：
**“拍个斜边，提取 ESF，求导得 LSF，做 FFT 得 MTF。”**

这就是每一次你用 Imatest 或写 Python 代码分析镜头画质时，计算机在毫秒间完成的工作。

---